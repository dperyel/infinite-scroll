{"version":3,"sources":["utils/data-structures/DoublyLinkedList.ts","components/ImageTape/Image.tsx","utils/image/types.ts","utils/image/VisibleImageList.ts","components/ImageTape/useScroll.ts","components/ImageTape/ImageBlock.tsx","components/ImageTape/Tape.tsx","components/Search/SearchForm.tsx","components/Search/useQuery.ts","utils/image/ImageInfoList.ts","utils/image/ImageNode.ts","utils/data-structures/Node.ts","utils/requestUtils.ts","utils/request/GiphyApi.ts","components/App.tsx","components/DataLoader/WithLoadedData.tsx","index.tsx"],"names":["ErrorMessage","Image","_ref","imageInfo","info","images","preview","frameStyle","height","concat","width","backgroundImage","url","react_default","a","createElement","className","style","DoublyLinkedList","Object","classCallCheck","this","head","tail","createClass","key","value","fn","result","getNext","Error","CorruptedList","currentNode","iterateTo","mappedValue","getValue","push","dataReducerFn","reducer","JSON","stringify","mapToArray","join","VisibleImageList","_DoublyLinkedList","possibleConstructorReturn","getPrototypeOf","apply","arguments","inherits","directionFn","newHead","newTail","setHead","setTail","NoHead","SameTail","shiftRight","imageNode","shiftLeft","getPrevious","defaultImageTapeStyle","paddingTop","paddingBottom","getHeightFromNode","node","Number","ImageBlock","props","imageList","approachingBottomNotifier","containerRef","React","createRef","_useScroll","infoList","appRoachingBottomNotifyer","_useState","useState","_useState2","slicedToArray","visibleList","setVisibleList","_useState3","_useState4","imageTapeStyle","setImageTapeStyle","useEffect","getHead","visibleContainerHeight","i","listHeight","image","reduce","acc","list","onScroll","current","containerPosition","getBoundingClientRect","viewportHeight","window","innerHeight","bottom","shiftedList","shiftList","topNodeHeight","bottomNodeHeight","getTail","top","addEventListener","removeEventListener","useScroll","react","ref","Image_Image","id","Tape","getSize","ImageBlock_ImageBlock","SearchForm","setQuery","onQueryChange","debounce","length","undefined","query","timer","setTimeout","clearTimeout","useQuery","placeholder","type","onChange","e","newText","target","trim","ImageInfoList","_getPrototypeOf2","_this","_len","args","Array","_key","call","size","tmpTail","setNext","setPrev","ImageNode","_Node","Node","next","prev","left","right","toUrl","link","urlParams","paramsAsString","keys","map","paramName","param","toString","paramsToAttach","encodeURI","GiphyApi","apiKey","_search","asyncToGenerator","regenerator_default","mark","_callee","signal","offset","res","body","_args","wrap","_context","api_key","q","limit","rating","lang","fetch","sent","json","meta","status","abrupt","responseAdaptor","t0","stop","_x","_x2","response","data","title","fixed_width_downsampled","pagination","objectSpread","App","Component","apiStrategy","giphyApi","TapeWithData","setImageList","approachingBottom","setApproachingBottom","_useState5","_useState6","paginationData","setPaginationData","abortRequestController","AbortController","search","then","_ref2","add","abort","count","_ref3","SearchForm_SearchForm","ReactDOM","render","src_components_App","document","getElementById"],"mappings":"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","file":"static/js/main.8517feef.chunk.js","sourcesContent":["import { Node } from \"./Node\";\nimport { Nullable } from \"./types\";\n\nenum ErrorMessage {\n    CorruptedList = \"Tail stays either out of the list or left to head\",\n}\n\nexport class DoublyLinkedList<T, G extends Node<T>> {\n\n    protected head: Nullable<G>;\n    protected tail: Nullable<G>;\n\n    public constructor() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    public setHead(head: G) {\n        this.head = head;\n\n        return this;\n    }\n\n    public getHead() {\n        return this.head;\n    }\n\n    public setTail(tail: G) {\n        this.tail = tail;\n\n        return this;\n    }\n\n    public getTail() {\n        return this.tail;\n    }\n\n    public mapToArray<K>(fn: (data: any) => K): K[] {\n        const result: K[] = [];\n\n        if (!this.head) {\n            return result;\n        }\n\n        if (this.tail && this.head === this.tail.getNext()) {\n            throw new Error(ErrorMessage.CorruptedList);\n        }\n\n        let currentNode: Nullable<Node<T>> = this.head;\n        const iterateTo = this.tail ? this.tail.getNext() : null;\n    \n        while(currentNode !== iterateTo) {\n            if (!currentNode) {\n                throw new Error(ErrorMessage.CorruptedList);\n            }\n\n            const mappedValue = fn(currentNode.getValue());\n            result.push(mappedValue);\n\n            currentNode = currentNode.getNext();\n        }\n    \n        return result;\n    }\n\n    public toString(dataReducerFn?: (data: T) => string) {\n        const reducer = dataReducerFn\n            ? dataReducerFn\n            : (value: T) => JSON.stringify(value);\n\n        const result = this.mapToArray<string>(reducer);\n\n        return result.join(\" -> \");\n    }\n\n}\n","import React, { CSSProperties } from \"react\";\nimport { ImageInfo } from \"../../utils/image/types\";\nimport \"./Image.css\";\n\ninterface ImageProps {\n    info: ImageInfo;\n}\n\nexport const Image: React.FC<ImageProps> = ({ info }) => {\n\n    const imageInfo = info.images.preview;\n    const frameStyle: CSSProperties = {\n        height: `${imageInfo.height}px`,\n        width: `${imageInfo.width}px`,\n        backgroundImage: `url(${imageInfo.url})`,\n    }\n\n    return <div className=\"Image\" style={frameStyle} />\n}\n","\ninterface ImageUnit {\n    height: string;\n    url: string;\n    width: string;\n}\nexport interface ImageInfo {\n    id: string;\n    title: string;\n    images: {\n        preview: ImageUnit,\n    }\n}\n\nexport type ImageInfoMapper<T> = (imageInfo: ImageInfo) => T;\n\nexport enum ErrorMessage {\n    SameTail = \"Head and tail cannot be the same refferences\",\n    NoHead = \"Head node cannot be empty\",\n};\n","import { DoublyLinkedList } from \"../data-structures/DoublyLinkedList\";\nimport { ImageNode } from \"./ImageNode\";\nimport { ImageInfo, ErrorMessage } from \"./types\";\nimport { Nullable } from \"../data-structures/types\";\n\n/**\n * VisibleImageList is created for getting a slice of images which should be rendered\n * on a screen.\n * Important! Current data structure is differ from doubly linked list as `head` node might\n * contain a refference to a `previous` node as well as `tail` node can have a link to the\n * `next` node.\n * This allow easely shift the list up or down by changing only 2 refferences.\n */\nexport class VisibleImageList extends DoublyLinkedList<ImageInfo, ImageNode> {\n\n    /**\n     * Shifts the Visible list to a provided direction\n     * The list is shifted if no boundaries hited\n     * The method return a new instance if the list is shifted and the same reference if nothing changed\n     *\n     * @param directionFn\n     */\n    public shiftList(directionFn: (node: ImageNode) => Nullable<ImageNode>) {\n        const newHead = this.head && directionFn(this.head);\n        const newTail = this.tail && directionFn(this.tail);\n\n        if (newHead && newTail) {\n            return new VisibleImageList().setHead(newHead).setTail(newTail);\n        }\n\n        return this;\n    }\n\n    private validateList() {\n        if (!this.head) {\n            throw new Error(ErrorMessage.NoHead);\n        }\n\n        if (this.head === this.tail) {\n            throw new Error(ErrorMessage.SameTail);\n        }\n    }\n\n}\n","import { useEffect, useState, RefObject, CSSProperties } from \"react\";\nimport { VisibleImageList } from \"../../utils/image/VisibleImageList\";\nimport { ImageNode } from \"../../utils/image/ImageNode\";\nimport { ImageInfoList } from \"../../utils/image/ImageInfoList\";\nimport { Nullable } from \"../../utils/data-structures/types\";\n\nconst shiftRight = (imageNode: ImageNode) => imageNode.getNext();\nconst shiftLeft = (imageNode: ImageNode) => imageNode.getPrevious();\n\nconst defaultImageTapeStyle: CSSProperties = {\n    paddingTop: 0,\n    paddingBottom: 0,\n};\n\nconst visibleElements = 20;\nconst thresholdToSwapImages = 1000;\nconst defaultPaddingOnNewData = 10000;\n\nfunction getHeightFromNode(node: Nullable<ImageNode>): number {\n    if (node) {\n        return Number(node.getValue().images.preview.height);\n    }\n\n    return 0;\n}\ninterface UseScrollResult {\n    visibleList: VisibleImageList,\n    imageTapeStyle: CSSProperties,\n};\ntype UseScroll = (\n    infoList: ImageInfoList,\n    containerRef: RefObject<HTMLDivElement>,\n    appRoachingBottomNotifyer?: () => void) => UseScrollResult;\n\nexport const useScroll: UseScroll = (infoList, containerRef, appRoachingBottomNotifyer?) => {\n\n    const [visibleList, setVisibleList] = useState(new VisibleImageList());\n    const [imageTapeStyle, setImageTapeStyle] = useState(defaultImageTapeStyle);\n\n    useEffect(() => {\n        let tail: ImageNode = infoList.getHead() as ImageNode;\n        let visibleContainerHeight = 0;\n\n        for (let i = 0; i < visibleElements; i++) {\n            if (!tail.getValue()) {\n                break;\n            }\n            visibleContainerHeight += getHeightFromNode(tail);\n            tail = tail.getNext() as ImageNode;\n        }\n\n        const listHeight = infoList\n            .mapToArray<number>(image => Number(image.images.preview.height))\n            .reduce((acc, height) => acc += height, 0);\n\n        setImageTapeStyle({\n            paddingTop: 0,\n            paddingBottom: listHeight - visibleContainerHeight,\n        });\n\n        const list = new VisibleImageList()\n            .setHead(infoList.getHead() as ImageNode)\n            .setTail(tail);\n\n        setVisibleList(list);\n    }, [infoList]);\n\n    useEffect(() => {\n        const onScroll = () => {\n            if (containerRef.current) {\n                const containerPosition = containerRef.current.getBoundingClientRect();\n                const viewportHeight = window.innerHeight;\n\n                // TODO isolate it to a separate function with direction\n                if (containerPosition.bottom - viewportHeight < thresholdToSwapImages) {\n                    const shiftedList = visibleList.shiftList(shiftRight);\n                    if (shiftedList === visibleList) {\n                        return;\n                    }\n                    setVisibleList(shiftedList);\n\n                    const topNodeHeight = getHeightFromNode(visibleList.getHead());\n                    const bottomNodeHeight = getHeightFromNode(shiftedList.getTail());\n                \n                    let paddingBottom = imageTapeStyle.paddingBottom as number - bottomNodeHeight;\n                    const paddingTop = imageTapeStyle.paddingTop as number + topNodeHeight;\n\n                    if (paddingBottom < thresholdToSwapImages) {\n                        if (appRoachingBottomNotifyer) {\n                            appRoachingBottomNotifyer();\n                            // TODO the padding should be adjasted when we get actual data an know the size of new elements\n                            paddingBottom += defaultPaddingOnNewData;\n                        }\n                    }\n\n                    setImageTapeStyle({\n                        paddingBottom: paddingBottom,\n                        paddingTop: paddingTop,\n                    });\n\n                } else if (containerPosition.top + thresholdToSwapImages - 100 >= 0) {\n                    const shiftedList = visibleList.shiftList(shiftLeft);\n\n                    if (shiftedList === visibleList) {\n                        return;\n                    }\n\n                    setVisibleList(shiftedList);\n\n                    const topNodeHeight = getHeightFromNode(shiftedList.getHead());\n                    const bottomNodeHeight = getHeightFromNode(visibleList.getTail());\n\n                    const paddingBottom = imageTapeStyle.paddingBottom as number + bottomNodeHeight;\n                    const paddingTop = imageTapeStyle.paddingTop as number - topNodeHeight;\n\n                    setImageTapeStyle({\n                        paddingBottom: paddingBottom,\n                        paddingTop: paddingTop,\n                    });\n                }\n            }\n        };\n\n        window.addEventListener(\"scroll\", onScroll, false);\n\n        return () => {\n            window.removeEventListener(\"scroll\", onScroll, false);\n        };\n    });\n\n    return {\n        visibleList: visibleList,\n        imageTapeStyle: imageTapeStyle,\n    };\n\n}\n","import React, { Fragment, RefObject } from \"react\";\nimport { ImageInfoList } from \"../../utils/image/ImageInfoList\";\nimport { Image } from \"./Image\";\nimport { useScroll } from \"./useScroll\";\n\ninterface ImageBlockProps {\n    imageList: ImageInfoList;\n    approachingBottomNotifier: () => void;\n}\n\nexport const ImageBlock: React.FC<ImageBlockProps> = (props) => {\n\n    const { imageList, approachingBottomNotifier } = props;\n    const containerRef: RefObject<HTMLDivElement> = React.createRef();\n\n    const {\n        visibleList,\n        imageTapeStyle,\n    } = useScroll(imageList, containerRef, approachingBottomNotifier);\n\n    return (\n        <Fragment>\n            <div style={imageTapeStyle}>\n                <div ref={containerRef}>\n                    {visibleList.mapToArray(image => <Image key={image.id} info={image} />)}\n                </div>\n            </div>\n            <p>Loading...</p>\n        </Fragment>\n    );\n}","import React from \"react\";\nimport { ImageInfoList } from \"../../utils/image/ImageInfoList\";\nimport { ImageBlock } from \"./ImageBlock\";\nimport \"./Tape.css\";\n\nexport interface TapeProps {\n    imageList: ImageInfoList;\n    approachingBottomNotifier: () => void;\n}\n\nexport const Tape: React.FC<TapeProps> = (props) => {\n\n    return (\n        <div className=\"Tape\">\n            {props.imageList.getSize() === 0\n                ? <p>Loading...</p>\n                : <ImageBlock {...props} />}\n        </div>\n    );\n\n}\n","import React from \"react\";\nimport { OnQueryChange, useQuery } from \"./useQuery\";\nimport \"./SearchForm.css\";\n\ninterface SearchFormProps {\n    onQueryChange: OnQueryChange;\n    debounce?: number;\n}\n\nexport const SearchForm: React.FC<SearchFormProps> = ({ onQueryChange, debounce }) => {\n    const setQuery = useQuery(onQueryChange, debounce);\n\n    function onChange(e: React.ChangeEvent<HTMLInputElement>) {\n        const newText = e.target.value.trim();\n        setQuery(newText);\n    }\n\n    return (\n        <div className=\"SearchForm\">\n            <div className=\"SearchForm-inputWrapper\">\n                <input className=\"SearchForm-input\" placeholder=\"Search for: kittens\" type=\"text\" onChange={onChange} />\n            </div>\n        </div>\n    );\n}\n","import { useState, useEffect } from 'react';\n\nexport type OnQueryChange = (query: string) => void;\n\nexport const useQuery = (onQueryChange: OnQueryChange, debounce: number = 1000) => {\n\n    const [query, setQuery] = useState(\"\");\n\n    useEffect(() => {\n        if (!query) {\n            return;\n        }\n\n        const timer = setTimeout(() => {\n            onQueryChange(query);\n        }, debounce);\n\n        return () => {\n            clearTimeout(timer);\n        };\n    });\n\n    return setQuery;\n}\n","import { DoublyLinkedList } from \"../data-structures/DoublyLinkedList\";\nimport { ImageInfo } from \"./types\";\nimport { ImageNode } from \"./ImageNode\";\n\n/**\n * ImageInfoList created for handling big list of data\n */\nexport class ImageInfoList extends DoublyLinkedList<ImageInfo, ImageNode> {\n    private size = 0;\n\n    public setSize(size: number) {\n        this.size = size;\n\n        return this;\n    }\n\n    public getSize() {\n        return this.size;\n    }\n\n    public add(node: ImageNode) {\n        if (!this.head) {\n            this.head = node;\n        } else if (this.tail) {\n            const tmpTail = this.tail;\n            tmpTail.setNext(node);\n            this.tail = node;\n            this.tail.setPrev(tmpTail);\n        } else {\n            this.tail = node;\n            this.tail.setPrev(this.head);\n            this.head.setNext(this.tail);\n        }\n\n        this.size += 1;\n\n        return this;\n    }\n}\n","import { Node } from \"../data-structures/Node\";\nimport { ImageInfo } from \"./types\";\n\nexport class ImageNode extends Node<ImageInfo> {\n}\n","import { Nullable } from \"./types\";\n\ntype NullableNode<T> = Nullable<Node<T>>;\n\nexport class Node<T> {\n\n    protected value: T;\n    protected next: NullableNode<T> = null;\n    protected prev: NullableNode<T> = null;\n\n    public constructor(value: T) {\n        this.value = value;\n    }\n\n    public getValue() {\n        return this.value;\n    }\n\n    public setNext(node: NullableNode<T>) {\n        this.next = node;\n\n        return this;\n    }\n\n    public getNext() {\n        return this.next;\n    }\n\n    public setPrev(node: NullableNode<T>) {\n        this.prev = node;\n\n        return this;\n    }\n\n    public getPrevious() {\n        return this.prev;\n    }\n\n    public toString(dataReducerFn?: (data: T) => string) {\n        const reducer = dataReducerFn ? dataReducerFn : JSON.stringify;\n        const left = this.prev ? reducer(this.prev.getValue()) : \"null\";\n        const right = this.next ? reducer(this.next.getValue()) : \"null\";\n        const value = reducer(this.value);\n\n        return `${left} <- ${value} -> ${right}`;\n    }\n\n}\n","\nexport type UrlParams = {[key: string]: number | string; };\n\nexport function toUrl(link: string, urlParams?: UrlParams) {\n\n    const paramsAsString = urlParams && Object.keys(urlParams).map(paramName => {\n        const param = urlParams[paramName].toString().trim();\n        return `${paramName}=${param}`;\n    }).join(\"&\");\n\n    const url = link.trim();\n    const paramsToAttach = paramsAsString ? `?${paramsAsString}` : \"\";\n\n    return encodeURI(url + paramsToAttach);\n}\n","import { RequestStrategy, DataResponse } from \"./types\";\nimport { toUrl } from \"../requestUtils\";\n\ninterface GiphyImageInfo {\n    id: string;\n    title: string;\n    images: {\n        fixed_width_still: {\n            height: string;\n            url: string;\n            width: string;\n        },\n        fixed_width_downsampled: {\n            height: string;\n            url: string;\n            width: string;\n        },\n    }\n}\n\nexport interface GiphyDataResponse {\n    data: GiphyImageInfo[];\n    meta: {\n        msg: string;\n        response_id: string;\n        status: number;\n    };\n    pagination: {\n        count: number;\n        offset: number;\n        total_count: number;\n    };\n} \n\nexport class GiphyApi implements RequestStrategy {\n\n    private apiKey: string;\n\n    public constructor(apiKey: string) {\n        this.apiKey = apiKey;\n    }\n\n    public async search(query: string, signal: AbortSignal, offset = 0) {\n        const url = toUrl(\"https://api.giphy.com/v1/gifs/search\", {\n            api_key: this.apiKey,\n            q: query,\n            limit: 100,\n            offset: offset,\n            rating: \"G\",\n            lang: \"en\",\n        });\n    \n        try {\n            const res = await fetch(url, { signal: signal });\n            const body: GiphyDataResponse = await res.json();\n        \n            if (body.meta.status === 200) {\n                return this.responseAdaptor(body);\n            } else {\n                throw new Error(`Status of the message is ${body.meta.status}`);\n            }\n        } catch (e) {\n            throw new Error(`Request was aborted`);\n        }\n    }\n\n    private responseAdaptor(response: GiphyDataResponse): DataResponse {\n        const data = response.data.map((imageInfo: GiphyImageInfo) => ({\n            id: imageInfo.id,\n            title: imageInfo.title,\n            images: {\n                preview: {\n                    height: imageInfo.images.fixed_width_downsampled.height,\n                    url: imageInfo.images.fixed_width_downsampled.url,\n                    width: imageInfo.images.fixed_width_downsampled.width, \n                },\n            }\n        }));\n        const meta = {\n            status: response.meta.status,\n        };\n        const pagination = { ...response.pagination };\n\n        return {\n            data: data,\n            meta: meta,\n            pagination: pagination,\n        }\n    }\n\n}\n","import React, { useState } from \"react\";\nimport \"./App.css\";\nimport { Tape } from \"./ImageTape/Tape\";\nimport { SearchForm } from \"./Search/SearchForm\";\nimport { withLoadedData } from \"./DataLoader/WithLoadedData\";\nimport { GiphyApi } from \"../utils/request/GiphyApi\";\n\nconst App: React.FC = () => {\n    const [query, setQuery] = useState(\"kittens\");\n    const giphyApi = new GiphyApi(\"VR8zLh7EW0IgB3AethVFn2iseXA94K6i\");\n    const TapeWithData = withLoadedData(Tape, giphyApi);\n\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <SearchForm onQueryChange={setQuery} />\n                <TapeWithData query={query} />\n            </header>\n        </div>\n    );\n}\n\nexport default App;\n","import React, { useEffect, useState } from \"react\";\nimport { ImageInfoList } from \"../../utils/image/ImageInfoList\";\nimport { ImageNode } from \"../../utils/image/ImageNode\";\nimport { TapeProps } from \"../ImageTape/Tape\";\nimport { RequestStrategy } from \"../../utils/request/types\";\n\ninterface WithLoadedDataProps {\n    query: string;\n}\n\n/**\n * withLoadedData expects to get a child component, which implements TapeProps interface\n * as a second parameter RequestStrategy should be provided so the child component get\n * data from an apropriate API\n *\n * @param Component \n * @param apiStrategy: RequestStrategy\n */\nexport function withLoadedData(Component: React.FC<TapeProps>, apiStrategy: RequestStrategy): React.FC<WithLoadedDataProps> {\n    return function WithLoadedData({ query }) {\n\n        const [imageList, setImageList] = useState(new ImageInfoList());\n        const [approachingBottom, setApproachingBottom] = useState(false);\n        const [paginationData, setPaginationData] = useState();\n\n        useEffect(() => {\n            const abortRequestController = new AbortController();\n\n            apiStrategy.search(query, abortRequestController.signal)\n                .then(({ data, pagination }) => {\n                    setPaginationData(pagination);\n                    const list = new ImageInfoList();\n\n                    for (let i = 0; i < data.length; i++) {\n                        const imageInfo = data[i];\n                        const imageNode = new ImageNode(imageInfo);\n                        list.add(imageNode);\n                    }\n\n                    setImageList(list);\n                });\n\n            return () => {\n                abortRequestController.abort();\n            }\n        }, [query]);\n\n        useEffect(() => {\n            if (approachingBottom) {\n                const abortRequestController = new AbortController();\n                const offset = paginationData.offset + paginationData.count;\n                apiStrategy.search(query, abortRequestController.signal, offset)\n                    .then(({ data, pagination }) => {\n                        setApproachingBottom(false);\n                        setPaginationData(pagination);\n\n                        // let adjustedHeight = 0;\n\n                        for (let i = 0; i < data.length; i++) {\n                            const imageInfo = data[i];\n                            const imageNode = new ImageNode(imageInfo);\n                            imageList.add(imageNode);\n\n                            // TODO notify useScroll with this value to adjust scroll\n                            // adjustedHeight += Number(imageInfo.images.preview.height);\n                        }\n                    });\n\n                return () => {\n                    abortRequestController.abort();\n                } \n            }\n        });\n\n        const onDataShouldBeLoaded = () => {\n            if (!approachingBottom) {\n                setApproachingBottom(true);\n            }\n        }\n\n        return (\n            <Component\n                imageList={imageList}\n                approachingBottomNotifier={onDataShouldBeLoaded} />\n        );\n\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}